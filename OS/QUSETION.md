
<details>
<summary>자바에서 객체를 생성하면 메모리 어느 부분에 할당되는지?</summary>
</details>


<details>
<summary>자바에서 Static 키워드와 전역 변수의 차이는?</summary>

자바에는 전역 변수라는 개념이 없다. 대신 static 변수가 그 역할을 비슷하게 수행하며, 프로그램이 시작될 때 메모리에 할당되고 종료 시 삭제된다.
이러한 static 변수는 JVM에서 메서드 영역(or class area)에 할당되고, 인스턴스 생성 없이 바로 접근 가능하다.
</details>

<details>
<summary>자바에서 객체를 생성하면 메모리 어느 부분에 할당되는지?</summary>
  
 Ans) 
**JVM이란?**
- JVM이란 Java Virtual Machine의 약자이며, 자바 가상 머신
- Java의 바이트 코드를 해석하고 실행하는 역할
- OS에 상관없이 실행할 수 있음

**JVM 실행 순서**
1.java 파일을 컴파일러(Compiler)를 통해 .class 파일로 변환함
2.class 파일을 JVM 의 ClassLoader(클래스로더)에게 보냄
3.클래스로더에서 JVM 런타임 영역으로 로딩(할당)하여 메모리에 올림 

**JVM의 RunTime Data Area(런타임 데이터 영역)**
- 클래스 로더가 .class 파일을 런타임 데이터 영역에 올림 
- 런타임 데이터 영역에는 5가지 영역이 존재한다.
- Static Area(Method Area)
- Heap Area
- Stack Area
- PC Register
- Native Method Stack 


**Java의 메모리 영역 **
- 자바 프로그램을 실행하게 되면 JVM(Java Virtual Machine)은 OS로 부터 메모리를 할당 받음
- 할당 받은 메모리를 자바 프로그램에 맞게 여러개의 영역으로 나누어 사용하게 됨
- JVM의 메모리는 3가지로 이루어져 있음
  1.Heap 영역
  2.Stack 영역
  3.Static (Method) 영역

**Java의 변수 종류**
public class Variable {
   public static int age = 20 ; // 클래스 변수 ( 전역 변수 ) 

 int height = 60; // 인스턴스 변수 ( 전역 변수 )

 public static void main(String[] args) { // 매개변수 ( 파라미터 ) 

 int size = 50; // 지역 변수
   }
}


**Static ( Method ) 영역 **
- JVM이 실행될 때, Class가 로딩될 때 생성됨
- Class의 정보, Static 변수 ( 클래스 변수 ) , 생성자 (Constructor) , 메소드(Method) 등 저장됨
- Static 영역에 있는 것은 어디서든 접근 가능함
- JVM 종료 시(프로그램 종료 시) 메모리에서 해제 됨


**Heap 영역**
- 인스턴스를 생성할 때 사용되는 메모리 영역
- 참조형 데이터 객체의 실제 데이터가 저장되는 공간임. 
즉, Stack 영역은 실제 데이터를 가지고 있고, Heap 영역은 참조값을 가지고 있음
- ex) new 키워드로 인스턴스를 생성 할 때, Heap 영역에는 생성된 객체가 저장, Stack 영역에서 생성된 객체에 대한 주소 값(Reference)이 저장됨.


**Stack 영역**
- 기본 자료형 ( Primitive type) , 지역 변수 그리고 매개변수가 저장되는 메모리 영역
- Heap 영역에 생성된 데이터의 참조값이 할당됨
- 메소드가 호출될 떄 메모리에 할당, 메서드 종료 시 메모리에서 삭제됨

ex) 
Car c1 = new Car();
1.Car : 클래스 영역에 Car 클래스가 로드됨
2.c1(참조 변수) : 스택 영역에 로드되며, 실제 값이 아닌 주소값을 가르킴 => 스택 영역
3.new : 실제로 객체 생성을 수행함
4.Car() : 이 생성자로 인스턴스가 생성되어 힙 영역에 로드됨. => 힙 영역
</details>

<details>
<summary>컴파일과 런타임, 프로그램 실행의 차이?</summary>
</details>

  
<details>
<summary>실행 시간 바인딩은 누가 담당하는지?</summary>
Ans ) 
프로그램이 실행한 후에도 물리적 주소가 변경될 수 있는 바인딩 방식이다. 런타임 바인딩에서는 CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 주소 매핑 테이블 을 이용해 주소 바인딩을 점검한다.
이때, “해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 주소 매핑 테이블 을 이용해 주소 바인딩을 점검”은 어디서 어떻게 이루어지는가?
Ans) MMU와 OS의 협력으로 이루어짐
</details>
  
<details>
<summary>논리적 주소와 피지컬 주소의 차이?</summary>
Ans) 
논리적 주소 : 프로세스 마다 독립적으로 가지는 주소 공간
물리적 주소 : 실제 메모리 하드웨어에 올라와 있는 주소
</details>

<details>  
<summary>스프링, 스프링 컨테이너, 웹 서버, 톰캣 그리고 서블릿, 서블릿 컨테이너의 차이는? </summary>
서블릿 이전에 CGI라는 서블릿의 조상님이 되는 기술이 있었다. 이러한 CGI는 사용자의 여러 요청에 동적으로 응답을 제공하기 위한 기술이였다.
또한 CGI는 복잡한 HTTP 메서드의 요청과 응답에 대한 문자열 파싱을 대신해주어, 개발자는 오로지 개발에만 집중할 수 있도록 도와준다. 
이때 서블릿은 자바 진영에서 동작하는 작은 자바 프로그램으로 CGI 규칙에 따라 HTTP 요청 및 응답을 주고 받는 것은 같지만, 
쓰레드 단위로 작업을 분리하여 대용량 트래픽에 대응 할 수 있도록 설계되었다.

서블릿 컨테이너는 이러한 서블릿을 실행하고 관리하는 환경을 제공한다. 즉 여러 HTTP 요청을 적절한 서블릿으로 라우팅하고, 생명주기를 관리하는 등의 역할을 한다.
이러한 서블릿 컨테이너의 구현체가 우리가 흔히 사용하는 톰캣(Tomcat)이다. 

일반적으로 Apache와 같은 웹 서버는 정적인 컨텐츠를 처리하고, 톰캣과 같은 WAS는 동적인 컨텐츠를 처리하는 역할을 한다.
그렇다면 왜 스프링은 Apache tomcat을 내장하고 있다고 할까? 
결론적으로 Apache와 tomcat의 기능은 나누어져 있지만 tomcat의 일부 기능이 정적인 컨텐츠를 처리하는 웹 서버의 역할을 어느정도 구현하기 때문에, 이를 합쳐서 부른다고 한다.

스프링은 자바 기반의 애플리케이션 개발을 위한 거대한 프레임워크이고, 스프링 부트는 이 스프링을 간편하게 사용하기 위한 도구이다.
스프링 부트는 내장 톰캣을 제공하여, 애플리케이션 자체에 톰캣 서버를 포함할 수 있다. 그래서 우리가 애플리케이션을 실행하기만 하면 외부 서버 설정없이 쉽게 배포가 가능한 것이다.

스프링 컨테이너는 스프링에서 IOC로 Bean을 관리하기 위해 제공하는 기능이다. 이를 통해 스프링은 객체의 관리와 생성을 모두 스프링 컨테이너에서 관리한다.
</details>



 
